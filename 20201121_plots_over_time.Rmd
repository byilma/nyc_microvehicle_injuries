---
title: "Plots over time"
date: "11/21/2020"
output: 
  github_document:
  always_allow_html: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(httr)
library(purrr)
library(leaflet)
options(scipen=999)

theme_set(theme_minimal() + theme(legend.position = "bottom"))
options(
  ggplot2.continuous.colour = "viridis",
  ggplot2.continuous.fill = "viridis"
)
scale_colour_discrete = scale_color_viridis_d
scale_fill_discrete = scale_fill_viridis_d

```


```{r import MV crash, include=FALSE}
#Importing crash data using the NYC Open Data API. The API response is limited to 50,000 rows, so we need a function that can be used to page through these results to capture all crashes in 2020. 
crash_api = function(offset, limit = 50000) {
  GET("https://data.cityofnewyork.us/resource/h9gi-nx95.csv", 
      query = list("$where" = "crash_date between '2017-01-01T00:00:0' and '2020-10-31T12:00:00'", "$limit" = limit, "$offset" = offset)) %>% 
  content("parsed") %>%
  as_tibble() %>% 
  select(-latitude, -longitude)
}

offsets = seq(0, 750000, by = 50000)

crash_dat = map_df(offsets, crash_api)
crash_dat = crash_dat %>% distinct
```


```{r, tidy MV crash}
#cleaning - transpose so vehicle types are listed in one column
crash_dat_tidy = 
  crash_dat %>% 
  mutate(
    date = lubridate::date(crash_date)
  ) %>% 
  pivot_longer(
    vehicle_type_code1:vehicle_type_code_5,
    names_to = "vehicle_number",
    values_to = "vehicle_options"
   ) %>%
  drop_na(vehicle_options)
```

```{r filtering for microvehicles}
#Exploring the vehicle types so that we can limit to bicycles -- double check this list
microvehicle_crash_agg = crash_dat_tidy %>%
  filter(str_detect(vehicle_options, "[Bb]ike") | 
           str_detect(vehicle_options, "REVEL") | 
           str_detect(vehicle_options, "SCO")  |
           str_detect(vehicle_options, "MOP")   |
           str_detect(vehicle_options, "ELEC")  |
           str_detect(vehicle_options, "^E-")) %>% 
  filter(vehicle_options != "ESCOVATOR" & vehicle_options != "Bike" &
      str_detect(vehicle_options, "Dirt", negate = TRUE),
      str_detect(vehicle_options, "[Mm]otorbike", negate = TRUE)
           ) %>% 
  group_by(date) %>% 
  summarize(daily_microveh_crashed = n()) 

microvehicle_crash_agg %>% 
  ggplot(aes(x = date, y = daily_microveh_crashed)) +
  geom_point(alpha = .5) +
  geom_smooth(se = FALSE)
           
#Run to check what the filter ^ resulted in
# bikes %>%
#   group_by(vehicle_options) %>%
#   count() %>% View()
```

```{r filtering for bikes}
#Exploring the vehicle types so that we can limit to bicycles -- double check this list
bike_crash_agg = crash_dat_tidy %>%
  filter(str_starts(vehicle_options, "[Bb]ike")) %>% 
  group_by(date) %>% 
  summarize(daily_bikes_crashed = n())

bike_crash_agg %>% 
  ggplot(aes(x = date, y = daily_bikes_crashed)) +
  geom_point(alpha = .5) +
  geom_smooth(se = FALSE)
  
           
#Run to check what the filter ^ resulted in
# bike_crash_dat %>%
#   group_by(vehicle_options) %>%
#   count() %>% View()

```


Probably can exclude this next section:
```{r line plot of crashes over time}
#for the line plot, we will want a summary of the number of bike crashes by day. The collisions variable calculates the number of unique crashes and the bikes variable calculates the total number of bikes that crashed (there can be mutliple bikes involved in one crash but this is rare)
# crash_date_summ = 
#   crash_dat %>%
#   filter(str_detect(vehicle_options, "[Bb]ike")) %>%
#   group_by(year, month, day) %>%
#   summarize(
#     collisions = n_distinct(collision_id),
#     bikes = n()
#   )


#simple plot just to see what the data look like
crash_date_summ %>%
  ggplot(aes(x = paste(month, day, sep="-"), y = collisions, 
             group = year, color = as.factor(year))) +
  geom_point(alpha = .5) +
  geom_smooth(se = FALSE) + 
  labs(
    title = "Number of Collisions Over Time in January-October of 2019 and 2020",
    x = "Month and Day",
    y = "Number of Collisions"
    ) +
  theme(text = element_text(size = 15), 
        axis.text.x = element_text(angle = 60, hjust=1, size=10)) +
  scale_colour_discrete("Year")

```



```{r import bikes}
#Importing bike data using the NYC Open Data API. The API response is limited to 50,000 rows, so we need a function that can be used to page through these results to capture all bike counts in 2019 and 2020. 

#I think the code below works
bike_api = function(offset, limit = 50000) {
  GET("https://data.cityofnewyork.us/resource/uczf-rk3c.csv", 
      query = list("$where" = "date between '2017-01-01T00:00:00' and '2020-10-31T12:00:00'", "$limit" = limit, "$offset" = offset)) %>% 
  content("parsed") %>%
  as_tibble() 
}

offsets = seq(0, 1800000, by = 50000)
bike_dat = map_df(offsets, bike_api)
```


```{r tidy bikes}
bike_counts_aggregate = 
  bike_dat %>% 
  mutate(
    date_time = date,
    date = lubridate::date(date_time)
  ) %>% 
  group_by(date) %>% 
  summarize(total_daily_bikes = sum(counts, na.rm = TRUE))

# Look at simple graph of bike counts by day, analagous to the one of crashes above.
bike_counts_aggregate %>%
  ggplot(aes(x = date, y = total_daily_bikes)) +
  geom_point(alpha = .5) +
  geom_smooth(se = FALSE)
```

